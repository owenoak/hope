===========
 Metaphors 
===========


Questions
	- are "book" and "app" different bases?
	- template pages for books
	- where does 'data' go?
		- page and/or app?
		- global?
		- eg: for statsproxy, 'services/instances' are app-level, stats/graph is page level?
				- item 1 of page data "services"
				- item 1 of services 



* Target problem space:
	- dynamic data sets:
		- wanda
		- statsproxy
		- appliance UIs
	- exploded page model
		- catalog
		- books
		- help system
		- wiki


* Stick close to the card/background/stack metaphor, but update for the web
	- rename old concepts:
		- "app" ("stack")
		- "skin" ("bkgnd")
		- "page" ("card")
		- "widgets" ("button", "field" etc)		-- name?

	- new stuff
		- "server" 		: our main web server: authentication, etc
		- "data source"	: client/server data sources, specified at app level  ("api"?)
		- "overlays"	: non-full-screen 'pages', specified at app level
		- "user"?		: model of the user, base for authentication

	- global reference to app/skin/page/etc as "things"
		- "[the] page", "page x", "page #", "[the] next page"
		- "[the] skin"
		- "[the] app"
		- "[the] server"
		- "[page] widget x", "skin widget y", "app widget z"
		- "overlay x"
		- "data source x"


* Server
	- provides:
		- authentication
		- navigation between apps
		- common functionality (rare)
		
	- server is composed of:
		- url (may not be a top-level url)
		- scripts
		- a simple role based permission scheme
		- message dictionary
		- reference to a set of apps


* Data Source
	- serves/saves a concrete set of operations and/or data models
	- can come from many back-ends (RDBMS, files, couchdb, etc)
	- used for getting/setting data
	- does own online/offline management
	- uses api pattern to expose operations
		- apps/etc use notification pattern to watch operations


* User
	- better name?
	- concrete model for the user
	- user has:
		- name
		- email
		- roles
		- preferences


* App:
	- is a single top-level URL
		- load libs once per app 
		- pre-load all widgets used in the app?  or per page?
	- only one main app is active at a time
	- app knows about all of its pages, but they're not necessarily all loaded
	- you can send messages/make requests/etc to a page if it's unloaded and it will be loaded automatically
	- page navigation
		- does NOT require reloading the app
		- may require loading the page in the background
		- can see an overview of the pages in the app (at least the main pages, at least in the editor)
	- an app is composed of:
		- meta-info
			- a friendly name
			- a url
			- a permission expression to view
			- a password to allow edits (see "edit mode" below)
			- thumbnail
		- app-level scripts
		- message dictionary (overlaid with server)
		- reference to a skin
		- reference to a set of pages
		- reference to a set of overlays
		- reference to a set of data sources
		- app widgets, common across pages, which slot into skin regions for display
			- eg: search, login button, page navigator, reload timer


* Skin
	- is background + styles + layout of major pieces + common widgets
	- all pages of an app share the same skin
	- exactly one skin is active for an app at a given time

	- same app can fit in many skins
		- mobile is just a smaller skin
		- different skins for different iPad orientations, etc
		- can dynamically load different skins if they are available (with a reload)

	- a skin is composed of:
		- meta info
			- a friendly name

		- scripts (?)
		- css files:
			- generic hope skin css
			- skin css file(s)
			- branding overlay(s)
			- includes appearance for overlays
			
		- regions:
			- are named 'sections' of the app that the page/skin/app components slot in to
			- can be dynamically hidden/rearranged for different pages
			- are either displayed as part of the main layout, or are overlays
			- have their own (simple) internal layout, 
				generally hstack or vstack, but a grid is possible
			- in edit mode, top-level widgets without a region are grouped together (think timers)
				in a ghostly pull-out-from-the-side drawer
	
		- layouts:
			- are named
			- there is one main layout active at any time ("the layout")
			- layouts are done with a simple grid system (think rhythm)
			- layouts can fix to window size or scroll or do the gear6-stretch-to-bottom-but-scroll
			- can have different layouts for different dimensions, switch between automatically
				- we pick the best layout for the given screen size automatically
		
	- skins are perfect for co-branding
		- just dupe the skin, tweak it, link it in to your app
		- overlays ala XUL?


* Page
	- is a distinct 'place' in the app
		- eg: in SP, we have 'overview', 'memcache stats', 'memcache traffic' and 'brutus details'
		- eg: in wanda, each type of thing is a separate page (guide book, map, etc)
		- eg: in a catalog, each laid-out page is a separate page, plus "cart" and 
		
	- only one main page is active at a time
	- pages are:
		- named with a friendly name (can be multiple words) which is shown to the user
			- for exploded catalog, name may be a number
		- composed of panels which slot into sections in the skin (for full-screen pages)
		- either full-screen or a dialog (panel?)
			- each full-screen page is a #history item so it can be bookmarked
			- sub-parts of a page may also be in history, #page/part/part/part
			- dialogs are *not* in the #history
	- have:
		- role-based and arbitrary permissions to be shown
		- a list of all of the classes used on the page

	- a page is composed of:
		- meta info:
			- a friendly name (may be a number for exploded catalog)
			- a permission expression
			- list of all of the classes/widgets used on the page
			- a thumbnail for display in the site map
			- preload flag
		- scripts
		- single css file which we page in and out?
		- a set of widgets which slot into skin components
			- widgets may have sub-widgets which do their own layout/etc
	
	- singleton pages w/dynamic content vs. exploded pages in a catalog
		- dynamic pages are 
		


* Overlay
	- like a page, but shown not-full-screen (think WindowScript)
		- eg:	prompt  (ask, answer, password, login)
		- eg:	growl-style notification
		- eg:	tool palette
		- eg:	error dialog
		- eg:	details view in a catalog
		- eg:	details hover in statsproxy
		- eg:	menu?

	- an overlay shares space with the current page
		- generally it floats on top
		- can be a side/top/etc panel which pushes the main layout around to fit

	- overlays can be shown/hidden dynamically

	- an overlay is composed of:
		- meta info
			- a friendly name
			- style:  floating, modal, dialog, hover, sticky hover, left panel, top panel, etc
			- scripts
			- a permission expression
			- list of all classes/widgets used in the overlay
			- a thumbnail
		- one or more top-level widgets (app or page)
	
	- hope has some default overlays:
		- alert (name?)
		- ask
		- answer
		- login  (username and/or password)
		- flasher
		- search (how to hook to back-end?)
	
	? can we insert a page from another app in an overlay?  via an iframe?

	


	





* Edit mode
	- saving changes to the app itself (vs the dynamic data in the app)
		 - we ONLY save changes to a page/skin/etc when we're in edit mode
		 - we auto-save changes when we leave edit mode (?) or switch page or...
		 - a script CAN go into edit mode and make changes IF you have permissions
		 - save changes as deltas in the app XML?
	- authentication for editing
		- you 'log in' to an app for editing via a password stored with the app somehow
			(rsa key or some such)
		- our server has a keychain concept, so you can stay logged in to apps you've edited already


MISC:
	- "tell" is an async indicator?
		- tell the server to do blah with blah
		 	when done
		 		...
		 	on error
		 		...
		  end tell
	
	- ListViewer
		- use ActiveRecord concept from aptana
		- "focus on row" -- shows only that row (eg: in SP with service list)
	- Undo
		- use a hidden iframe for history within the page?
