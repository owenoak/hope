h2. Element API
* Define our ideal API for elements

p.
|_.API|_.Description|
|.elements()|ElementList of child elements|
|.nodes()|ElementList of child nodes|
|.html()|get/set HTML|
|.add([#/element],element,...)|pass number first to add at location, -1 is end of list|
|.append(element,...)||
|.prepend(element,...)||
|.addBefore(oldElement, newElement,...)||
|.addAfter(oldElement, newElement,...)||
|.remove([#/element])||
|.replace([#/oldElement],newElement)||
|.wrap(container)|if container is string, will create element with that tagname|
|.contains(element,...)||
|.indexOf(element)||
|.empty()||
|.clone()||
|.matches(selector)||
|.select(selector,includeSelf)|selector is css selector string or function|
|.selectAll(selector,includeSelf)|selector is css selector string or function|
|.parent||
|.parents|ElementList of parents, closest first|
|.selectParent(selector)||
|.selectParents(selector)|ElementList of matching parents, closest first|
|.attributes()|{key:value} for all attributes, pass object to set|
|.attribute(key,value)|get/set/clear|
|.hasClass(class)||
|.addClass(class, condition)||
|.removeClass(class)||
|.isVisible||
|.show(newState)|uses animation style on element|
|.hide()|uses animation style on element|
|.enabled|checks parents|
|.enable(newState)||
|.disable()||
|.move(x,y)|in offset coordinates|
|.moveBy(x,y)|deltas|
|.left|offset left|
|.top|offset top|
|.right|offset right|
|.bottom|offset bottom|
|.pageLeft|global|
|.pageTop|global|
|.pageLeft|global|
|.pageTop|global|
|.width|incl. border+padding, not incl. margin|
|.height|incl. border+padding, not incl. margin|
|.innerWidth|does NOT incl. border, padding, margin|
|.innerHeight|does NOT incl. border, padding, margin|
|.resize(x,y)|uses animation style on element|
|.scroll|{left:x, top:y}|
|.maxScroll|{left:x, top:y}|
|.scrollTo(x,y)||
|.borders()|{left:,top:,right:,bottom:}|
|.margins()|{left:,top:,right:,bottom:}|
|.padding()|{left:,top:,right:,bottom:}|
|.absolutize()|? convert to same location, absolute positioning|
|.bringToFront()||
|.sendToBack()||
|.above(otherElement)||
|.below(otherElement)||

p.

* Place all directly on Element
** use DOMChanged event to recalculate
** send events to drawable hooked up?
* Create a lightning ElementList with same API, applied to first as makes sense
* Don't place on drawable -- we'll do this.element.forEach()...

h2. Event handling
* We have top-level, capture event handlers which:
** store properties of the event globally (mouse loc, button, key)
** set things up for special events
* We have top-level, bubbling event handlers, which:
** if we get there, we assume that any inline browser event handlers have already fired
** figure out the Drawable which received the event
** translate the event into special events (see below)
** send notify() of special events though the drawable heirarchy

h3. Mouse Events
* mousedown
* mousestilldown 	(aka _hold_ ?)
* mouseup
* click				(aka _tap_ ?)
* doubleclick		(aka _doubletap_ ?)
* tripleclick
* contextmenu
p.
* mousemove
* mouseenter
* mouseout
p.
* hover
* hoverout

h3. Keyboard Events
* focus
* blur
* keydown
* keypress
* keyup

h3. Page events
* scroll
* scrollwheel
* resize

h3. Drag Events
* dragstart
* drag (eg: dragmove)
* dragend
p.
* dragenter
* dragleave
* drop

h3. Gesture Events
* rotate
p.
* pinch open
* pinch closed
p.
* swipe left
* swipe right
* swipe up
* swipe down
p.
* flick left
* flick right
* flick up
* flick down
