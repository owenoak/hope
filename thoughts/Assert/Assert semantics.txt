What do we need to make the Assert XML work?
	- ASSUME
		- we have some sort of compilation process, which efficiently manages the binding behaviors
			so it's fast at runtime
				- can run on client or server (via rhino or spidermonkey or v8 or...)

		- 'dev' vs 'pre-compiled' modes so we can ship faster production code

	- COOL
		- we can use this to split Assert/Log into basic components (which don't require much infrastructure)
			and views which can take advantage of templates, etc.  
			This way we can still run Assert if the UI components are broken.

	- BASIC CONCEPT IDEAS
		- we have data items (Assert, Log) and UI items (AssertUI, LogViewer)

		- generic things, like ListViewer can adapt to any list with simple semantics
			- for complex semantics, make a subclass (eg: LogViewer)

		- XML objects can bind to global structures/classes


	- dynamic attributes:
		- #template:foo			(substitution vars? use scope? use binding?)
		- #message:foo			(substitution?)


	- binding/nesting
		- we will have a 'scope' object which we make available to children somehow with names of pieces
			- also default names:
				- 'site', 'app', 'page'
				- 'panel' -- panel that encloses you
				- 'section' -- section that encloses you

			- put each parent in generically by class name?
				(eg: app->panel->section->header->tooblar->button)

			- make scope a prototype object chain?
		
			- if we can't find something in the scope, assume it's a global path

		- bind drawables and all children to a particular data value:
			- bindTo = element to bind to, can be from parent's scope, goes into local scope
			- bindAs = alias for this element and below  
						- default is leaf of bindTo expression ( log.items.selected.test == test )
			

		- binding attributes values:
			- any (?) property can start with a "#", which means that we bind this attribute 
				to that property of the object

			- changing the property should change the object state automatically
				- use accessors for everything that is bound?	
				- notifications?
		
			- if attribute or any parent is not defined, value is empty string
		
			- #message:blah binds to an entry "blah" in a message file, eg
				<thing value='#message:blah' hint='#message:blah.hint'	/>
				
		
		- when parent binding changes, cascade down to all children
			- eg:  Assert.selected changes, all children with 'log' binding change automatically

			- means a lot of binding changing at runtime
				- compile all binding into a static function?

			- have some sort of memory of last state && check on timer?
	
	
		- need some way to map XML elements to HTML elements for CSS?
			- use 'name' rather than 'id' for everything other than top-level items
			- have 'name' hierarchy in CSS, in addition to 'type'?
	
			- children with 'name' get put in parent by name somehow, eg:
			
			- can specify templates inline if you want, or make external reference
	
	- layout
		- containers (Section, Header, Body, Footer) automatically have a layout pattern,
			defaulted according to their type
				- "flow", "horizontal", "vertical", etc

			- for horizontal layout, specify column widths with "cols" attribute
			- for vertical layout, specify "rows"
				- values are:
					- "auto"
					- <number> or "<number>" (pixels)
					- "xx%" for percentage
					- "*" (flex, # of starts == amount of relative flex)
				- if no rows/cols/etc specified, all are "auto"
				
			- child items can specify min and max sizes (NOT specified in the layout)
			- if percentages add up to more than 100%, we will scroll
			- 'priority' on children to decide who wins when there's not enough space?
			

		- containers can also have a 'scroll' attribute:
			- values:  "off", "auto", "scroll", "vertical" (auto), "horizontal" (auto)
			- scroll will automatically make an inset scrolling container

		- container can just specify 'value' as well for text/html content

	
	- listViewer
		- links to a List (or Tree)
		- manages selection  (single select and multiselect?)
			- how do we correlate selection back in the listViewer back to the original object?
				
		- how to draw?
			- listviewer.template == template to expand for 'chrome'
			- listviewer.itemTemplate == template to exand for each item, for simple lists only
				- for anything more complex, subclass ListViewer
			- listViewer.drawItem() == method to override for more complex semantics
			
			- how to do skipped, eg for log?  ListViewer subclass?
		

	- '#message' attribute means value for this element comes from a message file 
		- specify file location at Site, App, Page or component level
			- load messages in a prototype chain
		- assume single namespace, apps can a.b.c if they want uniqueness
		- how to take messages from template?  is all templated?


