Problems:
	1) Map XML declarative elements to JS objects, including custom classes
		- Attributes of solution:
			- don't have to fuss with strict loading (dependencies?)
			- can put things where they make sense, in XML or JS
			- things can be split in the XML in ways that make sense
				(eg: for simple Section or ListViewer, don't have to create a subclass)


	2) Map bindings of attribute values & data sources dynamically at runtime
		- Attributes of solution:
			- very fast to set up initial binding, can bind hundreds of values quickly
			- executing binding is as fast as direct coding
			- changing source object updates bound object and dependencies automatically & quickly
			- path.to.property is fault-tolerant if parts of path are not present
			- binding to a container cascades down to children
			- who we're bound to can change quickly, eg: list bound to a tree's selection
			- some sort of explicit + implicit scoping

		- Solution 1:  Scope + binding function
			- scoping:
				- as we build our XML/JS object heirarchy, each object	maintains a 'scope' object
				- scope objects use prototype inheritance to contain the scope of their parent
				- in XML setup, each named descendant (?) is added to scope of container
					(eg: AssertUI.scope.stop == stop button)
				- parents are added to scope of children by class:
					(eg: "stop" button has scope:  site, app, page, panel, section, header, toolbar)
				- bound objects are also added to scope under binding name
					(thus children inherit binding of their parents)
				- do scopes need pointers back to their parent scope?
			
			- binding function
				- for each 'bound' object we create an 'onBindingChange' function
					- this uses object's scope to bind data values to self and children who are not explicitly 'bound'
					- children who are explicitly 'bound' get their own 'onBindingChange' function
						and thus 'bound' children are a black box to their parent
						
				- for each 'bound' object, we set it up so when any of its top-level 'bindee's changes, 
					the 'onBindingChange' is called

					? do we need to worry about dynamic things, like "Assert.Suites.selected.log"
						or is that just handled in the scope?

					? is the 'binding' itself a proxy, so the 'binding' is notified when the change occurs,
						then propagates that to its children?
				
				- each parent has some easy, unambiguous way to reference children & children properties 
					for the binding function:
						? css-like syntax, eg:
							[#]		= nth child
							foo 	= child of type foo
							#foo 	= child (descendant?) of id "foo"
							:foo 	= child (descendant?) of name "foo"
							<a>.b	= property "b" of selector "a"

						  so within the AssertUI XML:
							
								path							reference
								------------------				-----------------------
								[0]								panel element (first child of AssertUI)
								panel							panel element
								panel section footer			footer element
								footer							footer element
								button:stop						stop button
								:stop							stop button
								:stop.enabled					"enabled" property of stop button

					- MUST accomodate children changing frequently AND be very fast

		- Solution 2 sketch
			- each element does its own binding of its data properties
				BUT we only start that process from places where there is a "bindTo"
				so we don't have to manage as many connections nor as many scopes
					- AssertUI binds
						- recursively calls children to do their own binding
							until we get to another 'bindTo' element
					
				- can optimize, that parent keeps a list of descendants who are dynamic, for speed if necessary

			- have a `this.scope(path)` which looks up heirarchy dynamically to find the right object?
